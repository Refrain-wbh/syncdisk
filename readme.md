##  网络同步盘的设计与实现 

- 网盘（网络 U 盘、网络硬盘）因为其便捷性被很多人青睐（目前国内多家网盘运营商停止服务，不是技术问题，而是管理与盈利问题，与本次作业无关，本次作业只讨论技术性问题），一个便捷的网盘服务，可以跨平台、跨地域，实现文件的存储、共享等功能；不需要随身携带存储介质，只要能上网，就能访问文件。 

- 网络同步盘是网盘的功能之一，具体形式为：机器上运行网络同步盘的客户端，在网盘上指定一个目录、本机上指定一个目录，两者绑定之后，将文件拖入本机目录，就会自动上传到网盘的指定目录下，如果用户再在另一台机器上运行网络同步盘的客户端并以同一账号登录，则网盘同步盘的文件会即时更新到另一台机器的本地目录中。 

***

#### 实现的功能

- 网盘的服务器操作系统确定为 CentOS 8，数据库系统使用 CentOS 8 自带的 MariaDB 10，编程语言为 C/C++，字符集为 GBK/GB18030 

#### 基本功能

- 新用户的注册，要求可以自定义用户名和密码，检查用户名是否重复

- 已有用户的登录，通过验证用户名和密码，允许合法的用户登录

- 用户名和密码在传输过程中不必考虑加密问题（即抓包可看到明文），但对密码的长度和强

  度要有一定要求，服务器上存储的密码必须是加密形式

- 用户登录成功后，可以看到自己账户下网盘的目录结构（允许为每个新用户定义一个初始

  目录结构，下含若干目录）

- 可以指定目录结构中的某个目录为同步目录，同步目录要允许更换
- 可以将本机上的某个目录与服务端指定的同步目录绑定/解绑，允许更换本机目录
- 客户端应该能看到同步过程的各种信息（日志）

#### 单机同步初始化

- 如果服务器的目录下有文件，要全部下载到本机的目录下

- 如果本机的目录下有文件，要全部上传到服务器目录下

- 服务器上的文件，如果内容相同（以 MD5 码/SHA 码的计算值为准），则真实文件**只允许**保留

  一份，然后产生两个链接（服务器上真实文件的命名规则可自行定义），因此相同文件向服

  务器的上传要做到“秒传”（例：本机的 CentOS8.iso 文件，已同步到服务器上，再复制一

  份为 CentOS8-dual.iso，则服务器秒传）

- 如果服务器目录下的文件和本机目录下的文件名相同且内容相同（以 MD5 码/SHA 码的计算

  值为准），则**不允许**再次上传/下载，要做到“秒同步”

- 如果服务器目录下的文件和本机目录下的文件名不同但内容相同（以 MD5 码/SHA 码的计算

  值为准），则以服务器上的文件名为准更改本机文件名

- 如果服务器目录下的文件和本机目录下的文件名相同但内容不同（以 MD5 码/SHA 码的计算

  值为准），则最终应该有两个文件

- 本机目录/服务器目录均可能包含下级子目录
- 初始同步完成后，本机和服务器对应目录的内容保持一致

#### 单机与服务端在初始同步完成后的同步规则（假设客户端始终在运行）

- 如果在本机目录下删除文件，则服务器对应删除（考虑服务器上该真实文件还有其它链

  接存在，无其它链接存在等情况）

- 如果在本机目录下删除下级子目录，则服务器对应删除 
- 在客户端运行时，除非解除绑定，**不允许**删除本机目录，如果本机目录不存在/在客户端未运行或解除绑定后被删除，则需要重新建立本机目录，按初始同步规则进行 
- 如果在本机上增加文件/子目录，则服务器对应增加 
- 如果在本机上修改文件名/子目录名，则服务器对应修改 
- **不需要**考虑直接在服务端增加文件

#### 多机（多个客户端在不同机器上以相同用户名登录）文件的同步规则

- 按两个单机-服务端的同步规则进行处理，服务端要考虑同步顺序的控制以避免冲突 
  - 如果 A机的 test1.dat与 B机的 test2.dat文件内容相同，同步后的命名规则应如何？ 
  - 如果 A 机和 B 机同时增加新文件 new.dat，但内容不同，应如何处理？ 
- A 机上删除文件/子目录后，B 机同步删除 
- A 机上增加文件/子目录后，B 机同步增加 
- A 机上文件/子目录改名后，B 机同步更改 
- 如果 A 机/B 机上有内容相同（MD5 码/SHA 码的值相同）的文件要同步到服务器上，可以选择先将某台机器的文件同步，完成后另外一台机器再“秒同步” 

***

#### 重点设计

**传输协议格式** 

（1）约定实地址为用户端地址，虚地址为服务器端地址，以下请求地址默认为实地址 

（2）请求类型等等只占一个字节，下面为了表示方便所以写成字符串 

（3）传输的原则是，一次请求对应一次回复。得到回复之后请求就结束。至于请求之间的逻辑关系是服务器和客户端自行负责。例如传输文件分为两步，第一步客户端向服务器发送传输文件请求，服务器给予答复（允许传输或者不允许传输）；第二步服务器向客户端索取文件，客户端传输。这样做会造成传输速度相对较慢的问题，因为每一次请求都需要有答复才能够进行，这是一种较为保险的措施，在真实的网络环境中，可能存在丢包等情况，我们在软件的层面上对信息的完整做出确认。但对于大文件的传输来说，可能效率较低，我们考虑可以一次请求多次应答，即一次请求很大的文件，然后客户端多次分批发出。

（4）{}表示一项，实际传输中会进行压缩

（5）项分为可变长度和不变长度，不变长度放在前面，这样可以用 struct 很方便地读取出不变的项目，并且可变长度项的长度也会被包含在内，所以根据这些长度读取剩下的内容即可。例如新增文件可以写成类似如下格式： 

```c++
struct acquire 
{ 
    int id; 
    int type; 
    char file_md5[32]; 
    int startpos; 
    int endpos; 
    int contentlen; 
};
```
这样做的原因是，当一个请求或者一个答复到达协议栈并且使用read/write读取的时候，并不知道这个请求是什么，以及这个包的长度有多长，这有赖于读取对于这些包的描述信息，才能够确定，所以需要将不变长度放在前面，并且关于这个包是什么类型的包的信息要放在最开头的部分。这样首先读取这个包的类型，然后根据类型来选择struct解析包的不变长度部分，根据不变长度部分中对可变长度的描述，来确定还需要读入多少字节，以及做什么样的操作。  
但对于读取网络协议栈信息的时候，我们并没有类似于peek这样的文件系统中的函数，也就是说，我们不能事先查看读到的内容是什么，也就无从确定应该要以什么格式读取。当然，我们可以先读取包头，然后读取不变长度，最后读取可变长度，但是这样的话就会调用3次read系统调用，这对于一个服务器来说是不可接受的性能损失。所以我们仿照CSAPP中的RIO的设计，为每个socket配备了缓冲区。每次尽可能地读出或者写入更多的字节，然后对于包的解析实际上是基于缓冲区上来进行的。于是便可以获得非常大的性能提升，以及操作上的简洁。关于RIO的设计下文中会详细解释。


1、删除文件 

请求：“{id} {delete} {addr_len}{file_addr}” 

回复：{id}{status} （status:删除成功、暂时无法删除、删除失败） 

2、 新增文件(只发送文件信息，此时需要打开，直到文件传输完成或者通知不需要传输文 

件) 

请求：“{id}{add}{file_md5}{file_time}{addr_len}{file_addr}” 

回复：{id}{status} （status:允许新增、暂时无法新增、无需新增） 

3、传输文件（真正进行文件传输） 

请求：“{id}{acquire}{file_md5}{start_pos}{end_pos}{addr_len}{file_addr}” 

回复：{id}{status}{start_pos}{end_pos}{content}文件传输内容包 

4、 修改文件（夹）名 

请求：“{id}{modify}{addr_len}{name_len}{file_addr}{file_name}” 

回复：“{id}{status}”(修改成功、失败、暂时无法修改) 

5、打印目录结构，该目录为虚目录 

请求：“{id}{print}{depth}{addr_len}{file_addr}” 

回复：“{id}{status}{tree_len}{tree}” 

6、注册 

请求：“{id}{register}{passwd_len}{name_len}{user_passwd} {user_name}”

回复：“{id}{status}” 成功、失败（包括失败原因） 

7、登录 

请求：“{id}{login}{count_len}{user_count}{user_passwd}” 

回复：“{id}{status}” 

登录后在服务端创建“socket”——“用户 id”的哈希表



**路径解析** 

- 在服务器和客户端交互过程中，客户端的实地址需要转化为服务器的虚地址才能在服务 器上存储，反之亦然。由于共享目录下的普通文件和文件夹两端是一致的，因此只需要对共享目录进行转化即可。可以建立一棵实地址共享文件夹的树，叶子节点存储虚地址，因而当读入一个实地址的时候，就根据实地址从树根开始移动，移动到叶子节点便将对应实地址改为虚地址即可。反之亦然。

  

**存储方案设计** 

- 如上面数据库所设计的那样，我们将会把用户的目录和文件以邻接表方式存入数据库中， 其中文件实际上只是一个虚文件，只是一个指向真实文件的连接。所谓邻接表，就是我们无论存储文件或者目录，需要记录其父级目录的id，通过这种方式找到父级目录，或者通过父亲目录来找到其下的所有文件。
  
- 关于文件的存储方式有很多中，其中常见的一种是将所有文件全部真实的存储在文件系统中，包括目录。也就是说将远程的文件目录完全存储在文件系统中。这样做的好处在于十分方便。但坏处是速度较慢，例如，如果目录下有大量的文件，那么为了找到这个文件，文件系统需要采用暴力遍历的方式来查找，速度的快慢取决于同一级目录下的文件数量，而数据库则可以通过索引等方式加快这一查找过程。 

- 上述过程是对于目录和指向文件的软连接的存储，而真实的文件内容，或者说真实的文件我们将会保存在服务器的一个指定位置上，并且就以文件的 MD5 码命名，由于 MD5 码是区分文件的唯一标志（在本问题中），因而这样不会出现冲突。 然后在数据库中记录该文件以及指向该文件的链接数，为 0 的时候理论上可以删除该文件 （无紧急情况会保留，以防止后面会再次恢复）这样同样会出现上述过程的问题，即一个目录下存在有海量文件，这样对于某个文件的查找效率极为低下，但由于所有的文件名都是MD5码，所以我们可以将MD5码的第一位作为一级目录，第二位作为二级目录，通过这样hash的方式减少单个目录下的文件数量，从而加快效率。因为MD5码的随机性，可以料想，每个目录下的文件数量应该是近似的，所以真实的查找效率为log(n)

  

**用户目录结构设计** 

- 用户目录是由上面的两张表构成，一张记录了服务器和客户端的共享文件夹对应关系， 并记录了这一对应关系是否绑定。通过这张表并配合虚实路径转换树（上文中的路径解析） 即可将客户端路径转化为虚路径（用户目录和用户文件），在服务器上以邻接表的方式存储 该虚目录和虚文件即可。

  

**实现断点续传和分块传输** 

- 上 文 中 谁 需 要 文 件 谁 发 送 request 请 求 ， 并 且 request 只 请 求 传 输 该 文 件 的 [start_pos,end_pos)范围内的字节。因此这个方法可以用于实现分块传输和断点续传。 

- 每接受指定长度的字节（8K）那么就会发生一次写入磁盘文件，此时传输未完成，并且随时可能被打断，所以要同时更新当前已经传输了多少字节，并且写入磁盘文件或者数据库。一旦发生突发情况，那么重新连接上去的时候根据这些未传输完毕的文件信息即可实现断点续传。

**性能优化**
- 作为服务器，应该要能够同时服务多个用户，所以必然的需要考虑性能优化的问题。在编程过程中，对于性能的提升主要做出了如下两个点的优化。首先是并发编程，其次是网络包缓冲区。

- 并发编程主要有三种方式，分贝是进程并发，线程并发和IO多路复用，进程并发的缺点就是不同进程之间的信息共享十分困难，另外不同进程的控制和IPC代价非常高。而线程并发如果设计良好则可以起到充分利用CPU的作用，但是对于本服务器的日常事务而言，以IO而非CPU为主，也就是说大部分时候是在等待IO，而需要的计算相对来说少的多。所以线程也没有必要。而IO多路复用则表现出了充分的优势，由于CPU计算少，所以大部分时候在等待IO，这样可以充分地利用等待期间处理其他的IO请求。我们使用了epoll作为实现多路复用方法，epoll采用触发机制来获取存在IO的连接，相比于select的轮询，效率更高。
  
- 此外，为了减少频繁地使用read、write系统调用来从协议栈中读取包，我们仿照CSAPP的RIO实现了网络包缓冲区。并且为每个fd配备了缓冲区。当发生读操作的时候，首先检查缓冲区内是否有所需要的字节数，如果有则直接读取，否则触发读协议栈，然后尽可能从协议栈中读取足够多的内容，这里可能会读取多次（因为为了性能起见，实现中所有的IO均为异步IO，所以可能存在没有完全读完就返回的情况）。将缓冲区填充完毕之后，然后再返回给用户所需要的内容。具体实现上面，采用了循环数组的方式，通过这种方式，可以充分利用缓冲区。而写操作则不太需要缓冲区，一方面，写操作不需要像读操作那样首先确定包的类型，然后才能够对包解析。另一方面，由于采用请求一次，回复一次的机制，所以大部分情况下都需要将写立即发出。但考虑到统一操作，还是保留了写缓冲区。